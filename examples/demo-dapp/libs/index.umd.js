!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@solana/web3.js"),require("buffer")):"function"==typeof define&&define.amd?define(["exports","@solana/web3.js","buffer"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).NewWallet={},null,e.buffer)}(this,(function(e,t,s){"use strict";var r,n,o;e.EthereumMessageType=void 0,(r=e.EthereumMessageType||(e.EthereumMessageType={})).READY="READY",r.CONNECT_WALLET="CONNECT_WALLET",r.SIGN_TRANSACTION="ETH_SIGN_TRANSACTION",r.SIGN_MESSAGE="ETH_SIGN_MESSAGE",e.SolanaMessageType=void 0,(n=e.SolanaMessageType||(e.SolanaMessageType={})).READY="READY",n.CONNECT_WALLET="CONNECT_WALLET",n.SIGN_MESSAGE="SOL_SIGN_MESSAGE",n.SIGN_TRANSACTION="SOL_SIGN_TRANSACTION",n.SIGN_ALL_TRANSACTIONS="SOL_SIGN_ALL_TRANSACTIONS",n.SIGN_AND_SEND_TRANSACTION="SOL_SIGN_AND_SEND_TRANSACTION",e.ErrorCode=void 0,(o=e.ErrorCode||(e.ErrorCode={}))[o.USER_REJECTED=4001]="USER_REJECTED",o[o.UNAUTHORIZED=4100]="UNAUTHORIZED",o[o.UNSUPPORTED_METHOD=4200]="UNSUPPORTED_METHOD",o[o.DISCONNECTED=4900]="DISCONNECTED",o[o.CHAIN_DISCONNECTED=4901]="CHAIN_DISCONNECTED",o[o.CHAIN_NOT_ADDED=4902]="CHAIN_NOT_ADDED",o[o.PARSE_ERROR=-32700]="PARSE_ERROR",o[o.INVALID_REQUEST=-32600]="INVALID_REQUEST",o[o.METHOD_NOT_FOUND=-32601]="METHOD_NOT_FOUND",o[o.INVALID_PARAMS=-32602]="INVALID_PARAMS",o[o.INTERNAL_ERROR=-32603]="INTERNAL_ERROR",o[o.INVALID_INPUT=-32e3]="INVALID_INPUT",o[o.RESOURCE_NOT_FOUND=-32001]="RESOURCE_NOT_FOUND",o[o.RESOURCE_UNAVAILABLE=-32002]="RESOURCE_UNAVAILABLE",o[o.TRANSACTION_REJECTED=-32003]="TRANSACTION_REJECTED",o[o.METHOD_NOT_SUPPORTED=-32004]="METHOD_NOT_SUPPORTED",o[o.LIMIT_EXCEEDED=-32005]="LIMIT_EXCEEDED",o[o.VERSION_NOT_SUPPORTED=-32006]="VERSION_NOT_SUPPORTED",o[o.UNKNOWN_ERROR=-1]="UNKNOWN_ERROR";const i={[e.ErrorCode.USER_REJECTED]:"The request was rejected by the user",[e.ErrorCode.UNAUTHORIZED]:"The requested method and/or account has not been authorized",[e.ErrorCode.UNSUPPORTED_METHOD]:"The requested method is not supported",[e.ErrorCode.DISCONNECTED]:"The provider is disconnected",[e.ErrorCode.CHAIN_DISCONNECTED]:"The provider is not connected to the requested chain",[e.ErrorCode.CHAIN_NOT_ADDED]:"The requested chain has not been added to the provider",[e.ErrorCode.PARSE_ERROR]:"Invalid JSON was received by the server",[e.ErrorCode.INVALID_REQUEST]:"The JSON sent is not a valid request object",[e.ErrorCode.METHOD_NOT_FOUND]:"The method does not exist / is not available",[e.ErrorCode.INVALID_PARAMS]:"Invalid method parameter(s)",[e.ErrorCode.INTERNAL_ERROR]:"Internal JSON-RPC error",[e.ErrorCode.INVALID_INPUT]:"Missing or invalid parameters",[e.ErrorCode.RESOURCE_NOT_FOUND]:"Requested resource not found",[e.ErrorCode.RESOURCE_UNAVAILABLE]:"Requested resource not available",[e.ErrorCode.TRANSACTION_REJECTED]:"Transaction creation failed",[e.ErrorCode.METHOD_NOT_SUPPORTED]:"Method is not implemented",[e.ErrorCode.LIMIT_EXCEEDED]:"Request exceeds defined limit",[e.ErrorCode.VERSION_NOT_SUPPORTED]:"Version of JSON-RPC protocol not supported",[e.ErrorCode.UNKNOWN_ERROR]:"Unknown error"};function a(t,s){return s||i[t]||i[e.ErrorCode.UNKNOWN_ERROR]}class c extends Error{constructor(e,t,s){super(a(e,t)),this.code=e,this.data=s,this.name=this.constructor.name,Object.setPrototypeOf(this,c.prototype)}}function l(e){const t=`newwallet-popup-${Date.now()}`,s=window.open(e,t,"width=400,height=600");if(!s)throw new Error("Failed to open wallet popup. Please allow popups for this site.");return s}function d(t){try{return{serializedTransaction:JSON.stringify(t,((e,t)=>"bigint"==typeof t?{type:"bigint",value:t.toString()}:t&&"object"==typeof t&&t.constructor&&"Address"===t.constructor.name?t.toString():t)),encoding:"json"}}catch(t){const s=t instanceof Error?t.message:String(t);throw new c(e.ErrorCode.INTERNAL_ERROR,`Failed to serialize Ethereum transaction: ${s}`)}}function E(t){try{const e=void 0!==t.version;let r;return r=e?s.Buffer.from(t.serialize()).toString("base64"):s.Buffer.from(t.serialize({verifySignatures:!1})).toString("base64"),{serializedTransaction:r,isVersionedTransaction:e,encoding:"base64"}}catch(t){const s=t instanceof Error?t.message:String(t);throw new c(e.ErrorCode.INTERNAL_ERROR,`Failed to serialize transaction: ${s}`)}}class _{constructor(e){this._connected=!1,this._accounts=[],this._chainId=null,this._eventListeners={},this._targetWalletUrl=e,this._targetWalletOrigin=new URL(e).origin}_buildRequest(e,t){return{type:e,network:"ethereum",timestamp:Date.now(),payload:t}}async request(t){const{method:s,params:r}=t;switch(s){case"eth_requestAccounts":return this._connect();case"eth_accounts":return this._accounts;case"eth_chainId":return this._chainId;case"personal_sign":return this._signMessage(null==r?void 0:r[0],null==r?void 0:r[1]);case"eth_signTransaction":return this._signTransaction(null==r?void 0:r[0]);case"eth_sendTransaction":return this._sendTransaction(null==r?void 0:r[0]);default:throw new c(e.ErrorCode.UNSUPPORTED_METHOD,`Method not supported: ${s}`)}}on(e,t){this._eventListeners[e]||(this._eventListeners[e]=[]),this._eventListeners[e].push(t)}off(e,t){this._eventListeners[e]&&(this._eventListeners[e]=this._eventListeners[e].filter((e=>e!==t)))}_emit(e,...t){this._eventListeners[e]&&this._eventListeners[e].forEach((e=>e(...t)))}async _connect(){return new Promise(((t,s)=>{const r=l(this._targetWalletUrl);if(!r)return void s(new c(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let n=!1;const o=o=>{const{data:a,origin:l}=o;if(a.type===e.EthereumMessageType.READY&&l===this._targetWalletOrigin&&!n){const t=this._buildRequest(e.EthereumMessageType.CONNECT_WALLET);r.postMessage(t,this._targetWalletOrigin),n=!0}if(a.type===e.EthereumMessageType.CONNECT_WALLET&&l===this._targetWalletOrigin)if(i(),r.close(),a.payload.success)this._connected=!0,this._accounts=[a.payload.result.address],this._chainId=a.payload.result.chainId||"0x1",this._emit("accountsChanged",this._accounts),this._emit("chainChanged",this._chainId),t(this._accounts);else{const t=a.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;s(new c(t,a.payload.message))}},i=()=>{clearInterval(a),window.removeEventListener("message",o)},a=setInterval((()=>{r.closed&&(i(),s(new c(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",o)}))}async _signMessage(t,s){if(!this._connected)throw new c(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");if(!this._accounts.includes(s))throw new c(e.ErrorCode.UNAUTHORIZED,"Not connected to the requested account. Please connect first.");return new Promise(((s,r)=>{const n=l(this._targetWalletUrl);if(!n)return void r(new c(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let o=!1;const i=i=>{const{data:l,origin:d}=i;if(l.type===e.EthereumMessageType.READY&&d===this._targetWalletOrigin&&!o){const s=this._buildRequest(e.EthereumMessageType.SIGN_MESSAGE,{message:t,encoding:"json"});n.postMessage(s,this._targetWalletOrigin),o=!0}if(l.type===e.EthereumMessageType.SIGN_MESSAGE&&d===this._targetWalletOrigin)if(a(),n.close(),l.payload.success)s(l.payload.result.signature);else{const t=l.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new c(t,l.payload.message))}},a=()=>{clearInterval(d),window.removeEventListener("message",i)},d=setInterval((()=>{n.closed&&(a(),r(new c(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",i)}))}async _signTransaction(t){if(!this._connected)throw new c(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");if(!t.from||!this._accounts.includes(t.from.toString()))throw new c(e.ErrorCode.UNAUTHORIZED,"From address not connected. Please connect the correct account.");return new Promise(((s,r)=>{const n=l(this._targetWalletUrl);if(!n)return void r(new c(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let o=!1;const i=i=>{const{data:l,origin:E}=i;if(l.type===e.EthereumMessageType.READY&&E===this._targetWalletOrigin&&!o){const{serializedTransaction:s,encoding:r}=d(t),i=this._buildRequest(e.EthereumMessageType.SIGN_TRANSACTION,{serializedTransaction:s,encoding:r});n.postMessage(i,this._targetWalletOrigin),o=!0}if(l.type===e.EthereumMessageType.SIGN_TRANSACTION&&E===this._targetWalletOrigin)if(a(),n.close(),l.payload.success)s(l.payload.result.signedTransaction);else{const t=l.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new c(t,l.payload.message))}},a=()=>{clearInterval(E),window.removeEventListener("message",i)},E=setInterval((()=>{n.closed&&(a(),r(new c(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",i)}))}async _sendTransaction(t){if(!this._connected)throw new c(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");if(!t.from||!this._accounts.includes(t.from.toString()))throw new c(e.ErrorCode.UNAUTHORIZED,"From address not connected. Please connect the correct account.");return new Promise(((s,r)=>{const n=l(this._targetWalletUrl);if(!n)return void r(new c(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let o=!1;const i=i=>{const{data:l,origin:E}=i;if(l.type===e.EthereumMessageType.READY&&E===this._targetWalletOrigin&&!o){const{serializedTransaction:s,encoding:r}=d(t),i=this._buildRequest(e.EthereumMessageType.SIGN_TRANSACTION,{serializedTransaction:s,encoding:r});n.postMessage(i,this._targetWalletOrigin),o=!0}if(l.type===e.EthereumMessageType.SIGN_TRANSACTION&&E===this._targetWalletOrigin)if(a(),n.close(),l.payload.success)s(l.payload.result.hash);else{const t=l.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new c(t,l.payload.message))}},a=()=>{clearInterval(E),window.removeEventListener("message",i)},E=setInterval((()=>{n.closed&&(a(),r(new c(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",i)}))}}class N{constructor(e){this._connected=!1,this._publicKey=null,this._eventListeners={},this._targetWalletUrl=e,this._targetWalletOrigin=new URL(e).origin}_buildRequest(e,t){return{type:e,network:"solana",timestamp:Date.now(),payload:t}}async connect(){return new Promise(((t,s)=>{const r=l(this._targetWalletUrl);if(!r)return void s(new c(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let n=!1;const o=o=>{const{data:a,origin:l}=o;if(a.type===e.SolanaMessageType.READY&&l===this._targetWalletOrigin&&!n){const t=this._buildRequest(e.SolanaMessageType.CONNECT_WALLET);r.postMessage(t,this._targetWalletOrigin),n=!0}if(a.type===e.SolanaMessageType.CONNECT_WALLET&&l===this._targetWalletOrigin)if(i(),r.close(),a.payload.success){const e=a.payload.result.publicKey;this._connected=!0,this._publicKey=e,this._emit("connect",e),t(e)}else{const t=a.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;s(new c(t,a.payload.message))}},i=()=>{clearInterval(a),window.removeEventListener("message",o)},a=setInterval((()=>{r.closed&&(i(),s(new c(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",o)}))}async disconnect(){this._connected&&(this._connected=!1,this._publicKey=null,this._emit("disconnect"))}isConnected(){return this._connected}getPublicKey(){return this._publicKey}async signMessage(t){if(!this._connected)throw new c(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");if(!this._publicKey)throw new c(e.ErrorCode.UNAUTHORIZED,"No public key available. Please connect first.");return new Promise(((s,r)=>{const n=l(this._targetWalletUrl);if(!n)return void r(new c(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let o=!1;const i=i=>{const{data:l,origin:d}=i;if(l.type===e.SolanaMessageType.READY&&d===this._targetWalletOrigin&&!o){const s=btoa(String.fromCharCode.apply(null,[...t])),r=this._buildRequest(e.SolanaMessageType.SIGN_MESSAGE,{message:s,encoding:"base64"});n.postMessage(r,this._targetWalletOrigin),o=!0}if(l.type===e.SolanaMessageType.SIGN_MESSAGE&&d===this._targetWalletOrigin)if(a(),n.close(),l.payload.success)s(l.payload.result.signature);else{const t=l.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new c(t,l.payload.message))}},a=()=>{clearInterval(d),window.removeEventListener("message",i)},d=setInterval((()=>{n.closed&&(a(),r(new c(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",i)}))}_verifyTransactionOwnership(t){if(!this._publicKey)throw new c(e.ErrorCode.UNAUTHORIZED,"No public key available. Please connect first.");if(t.feePayer){if(("function"==typeof t.feePayer.toString?t.feePayer.toString():t.feePayer)!==this._publicKey)throw new c(e.ErrorCode.UNAUTHORIZED,"Transaction fee payer does not match connected account.")}else{if(!(t.message&&t.message.staticAccountKeys&&t.message.staticAccountKeys.length>0))throw new c(e.ErrorCode.UNAUTHORIZED,"Unable to verify transaction ownership. Please ensure the transaction is properly constructed.");if(("function"==typeof t.message.staticAccountKeys[0].toString?t.message.staticAccountKeys[0].toString():t.message.staticAccountKeys[0])!==this._publicKey)throw new c(e.ErrorCode.UNAUTHORIZED,"Transaction first signer does not match connected account.")}}async signTransaction(t){if(!this._connected)throw new c(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");return this._verifyTransactionOwnership(t),new Promise(((s,r)=>{const n=l(this._targetWalletUrl);if(!n)return void r(new c(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let o=!1;const i=i=>{const{data:l,origin:d}=i;if(l.type===e.SolanaMessageType.READY&&d===this._targetWalletOrigin&&!o)try{const{serializedTransaction:s,isVersionedTransaction:r,encoding:i}=E(t),a=this._buildRequest(e.SolanaMessageType.SIGN_TRANSACTION,{serializedTransaction:s,isVersionedTransaction:r,encoding:i});n.postMessage(a,this._targetWalletOrigin),o=!0}catch(e){a(),n.close(),r(e)}if(l.type===e.SolanaMessageType.SIGN_TRANSACTION&&d===this._targetWalletOrigin)if(a(),n.close(),l.payload.success)s(l.payload.result.signedTransaction);else{const t=l.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new c(t,l.payload.message))}},a=()=>{clearInterval(d),window.removeEventListener("message",i)},d=setInterval((()=>{n.closed&&(a(),r(new c(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",i)}))}async signAllTransactions(t){if(!this._connected)throw new c(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");for(let e=0;e<t.length;e++)try{this._verifyTransactionOwnership(t[e])}catch(t){if(t instanceof c)throw new c(t.code,`Transaction at index ${e}: ${t.message}`);throw t}return new Promise(((s,r)=>{const n=l(this._targetWalletUrl);if(!n)return void r(new c(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let o=!1;const i=i=>{const{data:l,origin:d}=i;if(l.type===e.SolanaMessageType.READY&&d===this._targetWalletOrigin&&!o)try{const s=t.map(((e,t)=>{const{serializedTransaction:s,isVersionedTransaction:r,encoding:n}=E(e);return{serializedTransaction:s,isVersionedTransaction:r,encoding:n,index:t}})),r=this._buildRequest(e.SolanaMessageType.SIGN_ALL_TRANSACTIONS,{serializedTransactions:s});n.postMessage(r,this._targetWalletOrigin),o=!0}catch(e){a(),n.close(),r(e)}if(l.type===e.SolanaMessageType.SIGN_ALL_TRANSACTIONS&&d===this._targetWalletOrigin)if(a(),n.close(),l.payload.success)s(l.payload.result.signedTransactions);else{const t=l.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new c(t,l.payload.message))}},a=()=>{clearInterval(d),window.removeEventListener("message",i)},d=setInterval((()=>{n.closed&&(a(),r(new c(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",i)}))}async signAndSendTransaction(t){if(!this._connected)throw new c(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");return this._verifyTransactionOwnership(t),new Promise(((s,r)=>{const n=l(this._targetWalletUrl);if(!n)return void r(new c(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let o=!1;const i=i=>{const{data:l,origin:d}=i;if(l.type===e.SolanaMessageType.READY&&d===this._targetWalletOrigin&&!o)try{const{serializedTransaction:s,isVersionedTransaction:r,encoding:i}=E(t),a=this._buildRequest(e.SolanaMessageType.SIGN_AND_SEND_TRANSACTION,{serializedTransaction:s,isVersionedTransaction:r,encoding:i});n.postMessage(a,this._targetWalletOrigin),o=!0}catch(e){a(),n.close(),r(e)}if(l.type===e.SolanaMessageType.SIGN_AND_SEND_TRANSACTION&&d===this._targetWalletOrigin)if(a(),n.close(),l.payload.success)s(l.payload.result.signature);else{const t=l.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new c(t,l.payload.message))}},a=()=>{clearInterval(d),window.removeEventListener("message",i)},d=setInterval((()=>{n.closed&&(a(),r(new c(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",i)}))}on(e,t){this._eventListeners[e]||(this._eventListeners[e]=[]),this._eventListeners[e].push(t)}off(e,t){this._eventListeners[e]&&(this._eventListeners[e]=this._eventListeners[e].filter((e=>e!==t)))}_emit(e,...t){this._eventListeners[e]&&this._eventListeners[e].forEach((e=>e(...t)))}}e.ProviderError=c,e.createErrorResponse=function(e,t,s,r,n){return{type:e,network:t,payload:{success:!1,message:a(s,r),errorCode:s,result:n}}},e.createSuccessResponse=function(e,t,s,r="Success"){return{type:e,network:t,payload:{success:!0,message:r,result:s}}},e.default=class{constructor(e={}){const t=e.walletUrl||"https://newwallet.io/transaction_signing";this.ethereum=new _(t),this.solana=new N(t)}isInstalled(){return!0}},e.getErrorMessage=a,Object.defineProperty(e,"__esModule",{value:!0})}));
