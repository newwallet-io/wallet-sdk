!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).NewWallet={})}(this,(function(e){"use strict";var t,s,r;e.EthereumMessageType=void 0,(t=e.EthereumMessageType||(e.EthereumMessageType={})).READY="READY",t.CONNECT_WALLET="CONNECT_WALLET",t.SIGN_TRANSACTION="ETH_SIGN_TRANSACTION",t.SIGN_MESSAGE="ETH_SIGN_MESSAGE",e.SolanaMessageType=void 0,(s=e.SolanaMessageType||(e.SolanaMessageType={})).READY="READY",s.CONNECT_WALLET="CONNECT_WALLET",s.SIGN_MESSAGE="SOL_SIGN_MESSAGE",s.SIGN_TRANSACTION="SOL_SIGN_TRANSACTION",s.SIGN_ALL_TRANSACTIONS="SOL_SIGN_ALL_TRANSACTIONS",s.SIGN_AND_SEND_TRANSACTION="SOL_SIGN_AND_SEND_TRANSACTION",e.ErrorCode=void 0,(r=e.ErrorCode||(e.ErrorCode={}))[r.USER_REJECTED=4001]="USER_REJECTED",r[r.UNAUTHORIZED=4100]="UNAUTHORIZED",r[r.UNSUPPORTED_METHOD=4200]="UNSUPPORTED_METHOD",r[r.DISCONNECTED=4900]="DISCONNECTED",r[r.CHAIN_DISCONNECTED=4901]="CHAIN_DISCONNECTED",r[r.CHAIN_NOT_ADDED=4902]="CHAIN_NOT_ADDED",r[r.PARSE_ERROR=-32700]="PARSE_ERROR",r[r.INVALID_REQUEST=-32600]="INVALID_REQUEST",r[r.METHOD_NOT_FOUND=-32601]="METHOD_NOT_FOUND",r[r.INVALID_PARAMS=-32602]="INVALID_PARAMS",r[r.INTERNAL_ERROR=-32603]="INTERNAL_ERROR",r[r.INVALID_INPUT=-32e3]="INVALID_INPUT",r[r.RESOURCE_NOT_FOUND=-32001]="RESOURCE_NOT_FOUND",r[r.RESOURCE_UNAVAILABLE=-32002]="RESOURCE_UNAVAILABLE",r[r.TRANSACTION_REJECTED=-32003]="TRANSACTION_REJECTED",r[r.METHOD_NOT_SUPPORTED=-32004]="METHOD_NOT_SUPPORTED",r[r.LIMIT_EXCEEDED=-32005]="LIMIT_EXCEEDED",r[r.VERSION_NOT_SUPPORTED=-32006]="VERSION_NOT_SUPPORTED",r[r.UNKNOWN_ERROR=-1]="UNKNOWN_ERROR";const o={[e.ErrorCode.USER_REJECTED]:"The request was rejected by the user",[e.ErrorCode.UNAUTHORIZED]:"The requested method and/or account has not been authorized",[e.ErrorCode.UNSUPPORTED_METHOD]:"The requested method is not supported",[e.ErrorCode.DISCONNECTED]:"The provider is disconnected",[e.ErrorCode.CHAIN_DISCONNECTED]:"The provider is not connected to the requested chain",[e.ErrorCode.CHAIN_NOT_ADDED]:"The requested chain has not been added to the provider",[e.ErrorCode.PARSE_ERROR]:"Invalid JSON was received by the server",[e.ErrorCode.INVALID_REQUEST]:"The JSON sent is not a valid request object",[e.ErrorCode.METHOD_NOT_FOUND]:"The method does not exist / is not available",[e.ErrorCode.INVALID_PARAMS]:"Invalid method parameter(s)",[e.ErrorCode.INTERNAL_ERROR]:"Internal JSON-RPC error",[e.ErrorCode.INVALID_INPUT]:"Missing or invalid parameters",[e.ErrorCode.RESOURCE_NOT_FOUND]:"Requested resource not found",[e.ErrorCode.RESOURCE_UNAVAILABLE]:"Requested resource not available",[e.ErrorCode.TRANSACTION_REJECTED]:"Transaction creation failed",[e.ErrorCode.METHOD_NOT_SUPPORTED]:"Method is not implemented",[e.ErrorCode.LIMIT_EXCEEDED]:"Request exceeds defined limit",[e.ErrorCode.VERSION_NOT_SUPPORTED]:"Version of JSON-RPC protocol not supported",[e.ErrorCode.UNKNOWN_ERROR]:"Unknown error"};function n(t,s){return s||o[t]||o[e.ErrorCode.UNKNOWN_ERROR]}class a extends Error{constructor(e,t,s){super(n(e,t)),this.code=e,this.data=s,this.name=this.constructor.name,Object.setPrototypeOf(this,a.prototype)}}function i(e){const t=`newwallet-popup-${Date.now()}`,s=window.open(e,t,"width=400,height=600");if(!s)throw new Error("Failed to open wallet popup. Please allow popups for this site.");return s}class l{constructor(e){this._connected=!1,this._accounts=[],this._chainId=null,this._eventListeners={},this._targetWalletUrl=e,this._targetWalletOrigin=new URL(e).origin}_buildRequest(e,t){return{type:e,network:"ethereum",timestamp:Date.now(),payload:t}}async request(t){const{method:s,params:r}=t;switch(s){case"eth_requestAccounts":return this._connect();case"eth_accounts":return this._accounts;case"eth_chainId":return this._chainId;case"personal_sign":return this._signMessage(null==r?void 0:r[0],null==r?void 0:r[1]);case"eth_signTransaction":return this._signTransaction(null==r?void 0:r[0]);case"eth_sendTransaction":return this._sendTransaction(null==r?void 0:r[0]);default:throw new a(e.ErrorCode.UNSUPPORTED_METHOD,`Method not supported: ${s}`)}}on(e,t){this._eventListeners[e]||(this._eventListeners[e]=[]),this._eventListeners[e].push(t)}off(e,t){this._eventListeners[e]&&(this._eventListeners[e]=this._eventListeners[e].filter((e=>e!==t)))}_emit(e,...t){this._eventListeners[e]&&this._eventListeners[e].forEach((e=>e(...t)))}async _connect(){return new Promise(((t,s)=>{const r=i(this._targetWalletUrl);if(!r)return void s(new a(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let o=!1;const n=n=>{const{data:i,origin:E}=n;if(i.type===e.EthereumMessageType.READY&&E===this._targetWalletOrigin&&!o){const t=this._buildRequest(e.EthereumMessageType.CONNECT_WALLET);r.postMessage(t,this._targetWalletOrigin),o=!0}if(i.type===e.EthereumMessageType.CONNECT_WALLET&&E===this._targetWalletOrigin)if(l(),r.close(),i.payload.success)this._connected=!0,this._accounts=[i.payload.result.address],this._chainId=i.payload.result.chainId||"0x1",this._emit("accountsChanged",this._accounts),this._emit("chainChanged",this._chainId),t(this._accounts);else{const t=i.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;s(new a(t,i.payload.message))}},l=()=>{clearInterval(E),window.removeEventListener("message",n)},E=setInterval((()=>{r.closed&&(l(),s(new a(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",n)}))}async _signMessage(t,s){if(!this._connected)throw new a(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");if(!this._accounts.includes(s))throw new a(e.ErrorCode.UNAUTHORIZED,"Not connected to the requested account. Please connect first.");return new Promise(((r,o)=>{const n=i(this._targetWalletUrl);if(!n)return void o(new a(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let l=!1;const E=i=>{const{data:E,origin:c}=i;if(E.type===e.EthereumMessageType.READY&&c===this._targetWalletOrigin&&!l){const r=this._buildRequest(e.EthereumMessageType.SIGN_MESSAGE,{message:t,from:s});n.postMessage(r,this._targetWalletOrigin),l=!0}if(E.type===e.EthereumMessageType.SIGN_MESSAGE&&c===this._targetWalletOrigin)if(d(),n.close(),E.payload.success)r(E.payload.result.signature);else{const t=E.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;o(new a(t,E.payload.message))}},d=()=>{clearInterval(c),window.removeEventListener("message",E)},c=setInterval((()=>{n.closed&&(d(),o(new a(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",E)}))}async _signTransaction(t){if(!this._connected)throw new a(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");if(!t.from||!this._accounts.includes(t.from))throw new a(e.ErrorCode.UNAUTHORIZED,"From address not connected. Please connect the correct account.");return new Promise(((s,r)=>{const o=i(this._targetWalletUrl);if(!o)return void r(new a(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let n=!1;const l=i=>{const{data:l,origin:d}=i;if(l.type===e.EthereumMessageType.READY&&d===this._targetWalletOrigin&&!n){const s=this._buildRequest(e.EthereumMessageType.SIGN_TRANSACTION,t);o.postMessage(s,this._targetWalletOrigin),n=!0}if(l.type===e.EthereumMessageType.SIGN_TRANSACTION&&d===this._targetWalletOrigin)if(E(),o.close(),l.payload.success)s(l.payload.result.signedTransaction);else{const t=l.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new a(t,l.payload.message))}},E=()=>{clearInterval(d),window.removeEventListener("message",l)},d=setInterval((()=>{o.closed&&(E(),r(new a(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",l)}))}async _sendTransaction(t){if(!this._connected)throw new a(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");if(!t.from||!this._accounts.includes(t.from))throw new a(e.ErrorCode.UNAUTHORIZED,"From address not connected. Please connect the correct account.");return new Promise(((s,r)=>{const o=i(this._targetWalletUrl);if(!o)return void r(new a(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let n=!1;const l=i=>{const{data:l,origin:d}=i;if(l.type===e.EthereumMessageType.READY&&d===this._targetWalletOrigin&&!n){const s=this._buildRequest(e.EthereumMessageType.SIGN_TRANSACTION,t);o.postMessage(s,this._targetWalletOrigin),n=!0}if(l.type===e.EthereumMessageType.SIGN_TRANSACTION&&d===this._targetWalletOrigin)if(E(),o.close(),l.payload.success)s(l.payload.result.hash);else{const t=l.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new a(t,l.payload.message))}},E=()=>{clearInterval(d),window.removeEventListener("message",l)},d=setInterval((()=>{o.closed&&(E(),r(new a(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",l)}))}}class E{constructor(e){this._connected=!1,this._publicKey=null,this._eventListeners={},this._targetWalletUrl=e,this._targetWalletOrigin=new URL(e).origin}_buildRequest(e,t){return{type:e,network:"solana",timestamp:Date.now(),payload:t}}async connect(){return new Promise(((t,s)=>{const r=i(this._targetWalletUrl);if(!r)return void s(new a(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let o=!1;const n=n=>{const{data:i,origin:E}=n;if(i.type===e.SolanaMessageType.READY&&E===this._targetWalletOrigin&&!o){const t=this._buildRequest(e.SolanaMessageType.CONNECT_WALLET);r.postMessage(t,this._targetWalletOrigin),o=!0}if(i.type===e.SolanaMessageType.CONNECT_WALLET&&E===this._targetWalletOrigin)if(l(),r.close(),i.payload.success){const e=i.payload.result.publicKey;this._connected=!0,this._publicKey=e,this._emit("connect",e),t(e)}else{const t=i.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;s(new a(t,i.payload.message))}},l=()=>{clearInterval(E),window.removeEventListener("message",n)},E=setInterval((()=>{r.closed&&(l(),s(new a(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",n)}))}async disconnect(){this._connected&&(this._connected=!1,this._publicKey=null,this._emit("disconnect"))}isConnected(){return this._connected}getPublicKey(){return this._publicKey}async signMessage(t){if(!this._connected)throw new a(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");if(!this._publicKey)throw new a(e.ErrorCode.UNAUTHORIZED,"No public key available. Please connect first.");return new Promise(((s,r)=>{const o=i(this._targetWalletUrl);if(!o)return void r(new a(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let n=!1;const l=i=>{const{data:l,origin:d}=i;if(l.type===e.SolanaMessageType.READY&&d===this._targetWalletOrigin&&!n){const s=btoa(String.fromCharCode.apply(null,[...t])),r=this._buildRequest(e.SolanaMessageType.SIGN_MESSAGE,{message:s,encoding:"base64"});o.postMessage(r,this._targetWalletOrigin),n=!0}if(l.type===e.SolanaMessageType.SIGN_MESSAGE&&d===this._targetWalletOrigin)if(E(),o.close(),l.payload.success)s(l.payload.result.signature);else{const t=l.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new a(t,l.payload.message))}},E=()=>{clearInterval(d),window.removeEventListener("message",l)},d=setInterval((()=>{o.closed&&(E(),r(new a(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",l)}))}async signTransaction(t){if(!this._connected)throw new a(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");if(!this._publicKey)throw new a(e.ErrorCode.UNAUTHORIZED,"No public key available. Please connect first.");return new Promise(((s,r)=>{const o=i(this._targetWalletUrl);if(!o)return void r(new a(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let n=!1;const l=i=>{const{data:l,origin:d}=i;if(l.type===e.SolanaMessageType.READY&&d===this._targetWalletOrigin&&!n){const s=this._buildRequest(e.SolanaMessageType.SIGN_TRANSACTION,{transaction:t});o.postMessage(s,this._targetWalletOrigin),n=!0}if(l.type===e.SolanaMessageType.SIGN_TRANSACTION&&d===this._targetWalletOrigin)if(E(),o.close(),l.payload.success)s(l.payload.result.signedTransaction);else{const t=l.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new a(t,l.payload.message))}},E=()=>{clearInterval(d),window.removeEventListener("message",l)},d=setInterval((()=>{o.closed&&(E(),r(new a(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",l)}))}async signAllTransactions(t){if(!this._connected)throw new a(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");if(!this._publicKey)throw new a(e.ErrorCode.UNAUTHORIZED,"No public key available. Please connect first.");return new Promise(((s,r)=>{const o=i(this._targetWalletUrl);if(!o)return void r(new a(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let n=!1;const l=i=>{const{data:l,origin:d}=i;if(l.type===e.SolanaMessageType.READY&&d===this._targetWalletOrigin&&!n){const s=this._buildRequest(e.SolanaMessageType.SIGN_ALL_TRANSACTIONS,{transactions:t});o.postMessage(s,this._targetWalletOrigin),n=!0}if(l.type===e.SolanaMessageType.SIGN_ALL_TRANSACTIONS&&d===this._targetWalletOrigin)if(E(),o.close(),l.payload.success)s(l.payload.result.signedTransactions);else{const t=l.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new a(t,l.payload.message))}},E=()=>{clearInterval(d),window.removeEventListener("message",l)},d=setInterval((()=>{o.closed&&(E(),r(new a(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",l)}))}async signAndSendTransaction(t){if(!this._connected)throw new a(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");if(!this._publicKey)throw new a(e.ErrorCode.UNAUTHORIZED,"No public key available. Please connect first.");return new Promise(((s,r)=>{const o=i(this._targetWalletUrl);if(!o)return void r(new a(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let n=!1;const l=i=>{const{data:l,origin:d}=i;if(l.type===e.SolanaMessageType.READY&&d===this._targetWalletOrigin&&!n){const s=this._buildRequest(e.SolanaMessageType.SIGN_AND_SEND_TRANSACTION,{transaction:t});o.postMessage(s,this._targetWalletOrigin),n=!0}if(l.type===e.SolanaMessageType.SIGN_AND_SEND_TRANSACTION&&d===this._targetWalletOrigin)if(E(),o.close(),l.payload.success)s(l.payload.result.signature);else{const t=l.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new a(t,l.payload.message))}},E=()=>{clearInterval(d),window.removeEventListener("message",l)},d=setInterval((()=>{o.closed&&(E(),r(new a(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",l)}))}on(e,t){this._eventListeners[e]||(this._eventListeners[e]=[]),this._eventListeners[e].push(t)}off(e,t){this._eventListeners[e]&&(this._eventListeners[e]=this._eventListeners[e].filter((e=>e!==t)))}_emit(e,...t){this._eventListeners[e]&&this._eventListeners[e].forEach((e=>e(...t)))}}e.ProviderError=a,e.createErrorResponse=function(e,t,s,r,o){return{type:e,network:t,payload:{success:!1,message:n(s,r),errorCode:s,result:o}}},e.createSuccessResponse=function(e,t,s,r="Success"){return{type:e,network:t,payload:{success:!0,message:r,result:s}}},e.default=class{constructor(e={}){const t=e.walletUrl||"https://newwallet.io/transaction_signing";this.ethereum=new l(t),this.solana=new E(t)}isInstalled(){return!0}},e.getErrorMessage=n,Object.defineProperty(e,"__esModule",{value:!0})}));
