!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@solana/web3.js")):"function"==typeof define&&define.amd?define(["exports","@solana/web3.js"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).NewWallet={},e.web3_js)}(this,(function(e,t){"use strict";var s,r,n;e.EthereumMessageType=void 0,(s=e.EthereumMessageType||(e.EthereumMessageType={})).READY="READY",s.CONNECT_WALLET="CONNECT_WALLET",s.SIGN_TRANSACTION="ETH_SIGN_TRANSACTION",s.SIGN_MESSAGE="ETH_SIGN_MESSAGE",e.SolanaMessageType=void 0,(r=e.SolanaMessageType||(e.SolanaMessageType={})).READY="READY",r.CONNECT_WALLET="CONNECT_WALLET",r.SIGN_MESSAGE="SOL_SIGN_MESSAGE",r.SIGN_TRANSACTION="SOL_SIGN_TRANSACTION",r.SIGN_ALL_TRANSACTIONS="SOL_SIGN_ALL_TRANSACTIONS",r.SIGN_AND_SEND_TRANSACTION="SOL_SIGN_AND_SEND_TRANSACTION",e.ErrorCode=void 0,(n=e.ErrorCode||(e.ErrorCode={}))[n.USER_REJECTED=4001]="USER_REJECTED",n[n.UNAUTHORIZED=4100]="UNAUTHORIZED",n[n.UNSUPPORTED_METHOD=4200]="UNSUPPORTED_METHOD",n[n.DISCONNECTED=4900]="DISCONNECTED",n[n.CHAIN_DISCONNECTED=4901]="CHAIN_DISCONNECTED",n[n.CHAIN_NOT_ADDED=4902]="CHAIN_NOT_ADDED",n[n.PARSE_ERROR=-32700]="PARSE_ERROR",n[n.INVALID_REQUEST=-32600]="INVALID_REQUEST",n[n.METHOD_NOT_FOUND=-32601]="METHOD_NOT_FOUND",n[n.INVALID_PARAMS=-32602]="INVALID_PARAMS",n[n.INTERNAL_ERROR=-32603]="INTERNAL_ERROR",n[n.INVALID_INPUT=-32e3]="INVALID_INPUT",n[n.RESOURCE_NOT_FOUND=-32001]="RESOURCE_NOT_FOUND",n[n.RESOURCE_UNAVAILABLE=-32002]="RESOURCE_UNAVAILABLE",n[n.TRANSACTION_REJECTED=-32003]="TRANSACTION_REJECTED",n[n.METHOD_NOT_SUPPORTED=-32004]="METHOD_NOT_SUPPORTED",n[n.LIMIT_EXCEEDED=-32005]="LIMIT_EXCEEDED",n[n.VERSION_NOT_SUPPORTED=-32006]="VERSION_NOT_SUPPORTED",n[n.UNKNOWN_ERROR=-1]="UNKNOWN_ERROR";const o={[e.ErrorCode.USER_REJECTED]:"The request was rejected by the user",[e.ErrorCode.UNAUTHORIZED]:"The requested method and/or account has not been authorized",[e.ErrorCode.UNSUPPORTED_METHOD]:"The requested method is not supported",[e.ErrorCode.DISCONNECTED]:"The provider is disconnected",[e.ErrorCode.CHAIN_DISCONNECTED]:"The provider is not connected to the requested chain",[e.ErrorCode.CHAIN_NOT_ADDED]:"The requested chain has not been added to the provider",[e.ErrorCode.PARSE_ERROR]:"Invalid JSON was received by the server",[e.ErrorCode.INVALID_REQUEST]:"The JSON sent is not a valid request object",[e.ErrorCode.METHOD_NOT_FOUND]:"The method does not exist / is not available",[e.ErrorCode.INVALID_PARAMS]:"Invalid method parameter(s)",[e.ErrorCode.INTERNAL_ERROR]:"Internal JSON-RPC error",[e.ErrorCode.INVALID_INPUT]:"Missing or invalid parameters",[e.ErrorCode.RESOURCE_NOT_FOUND]:"Requested resource not found",[e.ErrorCode.RESOURCE_UNAVAILABLE]:"Requested resource not available",[e.ErrorCode.TRANSACTION_REJECTED]:"Transaction creation failed",[e.ErrorCode.METHOD_NOT_SUPPORTED]:"Method is not implemented",[e.ErrorCode.LIMIT_EXCEEDED]:"Request exceeds defined limit",[e.ErrorCode.VERSION_NOT_SUPPORTED]:"Version of JSON-RPC protocol not supported",[e.ErrorCode.UNKNOWN_ERROR]:"Unknown error"};function i(t,s){return s||o[t]||o[e.ErrorCode.UNKNOWN_ERROR]}class a extends Error{constructor(e,t,s){super(i(e,t)),this.code=e,this.data=s,this.name=this.constructor.name,Object.setPrototypeOf(this,a.prototype)}}function c(e){const t=`newwallet-popup-${Date.now()}`,s=window.open(e,t,"width=400,height=600");if(!s)throw new Error("Failed to open wallet popup. Please allow popups for this site.");return s}function l(t){try{return{serializedTransaction:JSON.stringify(t,((e,t)=>"bigint"==typeof t?{type:"bigint",value:t.toString()}:t&&"object"==typeof t&&t.constructor&&"Address"===t.constructor.name?t.toString():t)),encoding:"json"}}catch(t){const s=t instanceof Error?t.message:String(t);throw new a(e.ErrorCode.INTERNAL_ERROR,`Failed to serialize Ethereum transaction: ${s}`)}}function d(s){try{const e=s instanceof t.VersionedTransaction;let r;return r=e?Buffer.from(s.serialize()).toString("base64"):Buffer.from(s.serialize({verifySignatures:!1})).toString("base64"),{serializedTransaction:r,isVersionedTransaction:e,encoding:"base64"}}catch(t){const s=t instanceof Error?t.message:String(t);throw new a(e.ErrorCode.INTERNAL_ERROR,`Failed to serialize transaction: ${s}`)}}class E{constructor(e){this._connected=!1,this._accounts=[],this._chainId=null,this._eventListeners={},this._targetWalletUrl=e,this._targetWalletOrigin=new URL(e).origin}_buildRequest(e,t){return{type:e,network:"ethereum",timestamp:Date.now(),payload:t}}async request(t){const{method:s,params:r}=t;switch(s){case"eth_requestAccounts":return this._connect();case"eth_accounts":return this._accounts;case"eth_chainId":return this._chainId;case"personal_sign":return this._signMessage(null==r?void 0:r[0],null==r?void 0:r[1]);case"eth_signTransaction":return this._signTransaction(null==r?void 0:r[0]);case"eth_sendTransaction":return this._sendTransaction(null==r?void 0:r[0]);default:throw new a(e.ErrorCode.UNSUPPORTED_METHOD,`Method not supported: ${s}`)}}on(e,t){this._eventListeners[e]||(this._eventListeners[e]=[]),this._eventListeners[e].push(t)}off(e,t){this._eventListeners[e]&&(this._eventListeners[e]=this._eventListeners[e].filter((e=>e!==t)))}_emit(e,...t){this._eventListeners[e]&&this._eventListeners[e].forEach((e=>e(...t)))}async _connect(){return new Promise(((t,s)=>{const r=c(this._targetWalletUrl);if(!r)return void s(new a(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let n=!1;const o=o=>{const{data:c,origin:l}=o;if(c.type===e.EthereumMessageType.READY&&l===this._targetWalletOrigin&&!n){const t=this._buildRequest(e.EthereumMessageType.CONNECT_WALLET);r.postMessage(t,this._targetWalletOrigin),n=!0}if(c.type===e.EthereumMessageType.CONNECT_WALLET&&l===this._targetWalletOrigin)if(i(),r.close(),c.payload.success)this._connected=!0,this._accounts=[c.payload.result.address],this._chainId=c.payload.result.chainId||"0x1",this._emit("accountsChanged",this._accounts),this._emit("chainChanged",this._chainId),t(this._accounts);else{const t=c.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;s(new a(t,c.payload.message))}},i=()=>{clearInterval(l),window.removeEventListener("message",o)},l=setInterval((()=>{r.closed&&(i(),s(new a(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",o)}))}async _signMessage(t,s){if(!this._connected)throw new a(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");if(!this._accounts.includes(s))throw new a(e.ErrorCode.UNAUTHORIZED,"Not connected to the requested account. Please connect first.");return new Promise(((s,r)=>{const n=c(this._targetWalletUrl);if(!n)return void r(new a(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let o=!1;const i=i=>{const{data:c,origin:d}=i;if(c.type===e.EthereumMessageType.READY&&d===this._targetWalletOrigin&&!o){const s=this._buildRequest(e.EthereumMessageType.SIGN_MESSAGE,{message:t,encoding:"json"});n.postMessage(s,this._targetWalletOrigin),o=!0}if(c.type===e.EthereumMessageType.SIGN_MESSAGE&&d===this._targetWalletOrigin)if(l(),n.close(),c.payload.success)s(c.payload.result.signature);else{const t=c.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new a(t,c.payload.message))}},l=()=>{clearInterval(d),window.removeEventListener("message",i)},d=setInterval((()=>{n.closed&&(l(),r(new a(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",i)}))}async _signTransaction(t){if(!this._connected)throw new a(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");if(!t.from||!this._accounts.includes(t.from.toString()))throw new a(e.ErrorCode.UNAUTHORIZED,"From address not connected. Please connect the correct account.");return new Promise(((s,r)=>{const n=c(this._targetWalletUrl);if(!n)return void r(new a(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let o=!1;const i=i=>{const{data:c,origin:E}=i;if(c.type===e.EthereumMessageType.READY&&E===this._targetWalletOrigin&&!o){const{serializedTransaction:s,encoding:r}=l(t),i=this._buildRequest(e.EthereumMessageType.SIGN_TRANSACTION,{serializedTransaction:s,encoding:r});n.postMessage(i,this._targetWalletOrigin),o=!0}if(c.type===e.EthereumMessageType.SIGN_TRANSACTION&&E===this._targetWalletOrigin)if(d(),n.close(),c.payload.success)s(c.payload.result.signedTransaction);else{const t=c.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new a(t,c.payload.message))}},d=()=>{clearInterval(E),window.removeEventListener("message",i)},E=setInterval((()=>{n.closed&&(d(),r(new a(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",i)}))}async _sendTransaction(t){if(!this._connected)throw new a(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");if(!t.from||!this._accounts.includes(t.from.toString()))throw new a(e.ErrorCode.UNAUTHORIZED,"From address not connected. Please connect the correct account.");return new Promise(((s,r)=>{const n=c(this._targetWalletUrl);if(!n)return void r(new a(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let o=!1;const i=i=>{const{data:c,origin:E}=i;if(c.type===e.EthereumMessageType.READY&&E===this._targetWalletOrigin&&!o){const{serializedTransaction:s,encoding:r}=l(t),i=this._buildRequest(e.EthereumMessageType.SIGN_TRANSACTION,{serializedTransaction:s,encoding:r});n.postMessage(i,this._targetWalletOrigin),o=!0}if(c.type===e.EthereumMessageType.SIGN_TRANSACTION&&E===this._targetWalletOrigin)if(d(),n.close(),c.payload.success)s(c.payload.result.hash);else{const t=c.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new a(t,c.payload.message))}},d=()=>{clearInterval(E),window.removeEventListener("message",i)},E=setInterval((()=>{n.closed&&(d(),r(new a(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",i)}))}}class _{constructor(e){this._connected=!1,this._publicKey=null,this._eventListeners={},this._targetWalletUrl=e,this._targetWalletOrigin=new URL(e).origin}_buildRequest(e,t){return{type:e,network:"solana",timestamp:Date.now(),payload:t}}async connect(){return new Promise(((t,s)=>{const r=c(this._targetWalletUrl);if(!r)return void s(new a(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let n=!1;const o=o=>{const{data:c,origin:l}=o;if(c.type===e.SolanaMessageType.READY&&l===this._targetWalletOrigin&&!n){const t=this._buildRequest(e.SolanaMessageType.CONNECT_WALLET);r.postMessage(t,this._targetWalletOrigin),n=!0}if(c.type===e.SolanaMessageType.CONNECT_WALLET&&l===this._targetWalletOrigin)if(i(),r.close(),c.payload.success){const e=c.payload.result.publicKey;this._connected=!0,this._publicKey=e,this._emit("connect",e),t(e)}else{const t=c.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;s(new a(t,c.payload.message))}},i=()=>{clearInterval(l),window.removeEventListener("message",o)},l=setInterval((()=>{r.closed&&(i(),s(new a(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",o)}))}async disconnect(){this._connected&&(this._connected=!1,this._publicKey=null,this._emit("disconnect"))}isConnected(){return this._connected}getPublicKey(){return this._publicKey}async signMessage(t){if(!this._connected)throw new a(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");if(!this._publicKey)throw new a(e.ErrorCode.UNAUTHORIZED,"No public key available. Please connect first.");return new Promise(((s,r)=>{const n=c(this._targetWalletUrl);if(!n)return void r(new a(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let o=!1;const i=i=>{const{data:c,origin:d}=i;if(c.type===e.SolanaMessageType.READY&&d===this._targetWalletOrigin&&!o){const s=btoa(String.fromCharCode.apply(null,[...t])),r=this._buildRequest(e.SolanaMessageType.SIGN_MESSAGE,{message:s,encoding:"base64"});n.postMessage(r,this._targetWalletOrigin),o=!0}if(c.type===e.SolanaMessageType.SIGN_MESSAGE&&d===this._targetWalletOrigin)if(l(),n.close(),c.payload.success)s(c.payload.result.signature);else{const t=c.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new a(t,c.payload.message))}},l=()=>{clearInterval(d),window.removeEventListener("message",i)},d=setInterval((()=>{n.closed&&(l(),r(new a(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",i)}))}_verifyTransactionOwnership(s){if(!this._publicKey)throw new a(e.ErrorCode.UNAUTHORIZED,"No public key available. Please connect first.");if(s instanceof t.Transaction){if(s.feePayer){if(s.feePayer.toString()!==this._publicKey)throw new a(e.ErrorCode.UNAUTHORIZED,"Transaction fee payer does not match connected account.");return}}else if(s instanceof t.VersionedTransaction&&s.message&&s.message.staticAccountKeys&&s.message.staticAccountKeys.length>0){if(s.message.staticAccountKeys[0].toString()!==this._publicKey)throw new a(e.ErrorCode.UNAUTHORIZED,"Transaction first signer does not match connected account.");return}throw new a(e.ErrorCode.UNAUTHORIZED,"Unable to verify transaction ownership. Please ensure the transaction is properly constructed.")}async signTransaction(t){if(!this._connected)throw new a(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");return this._verifyTransactionOwnership(t),new Promise(((s,r)=>{const n=c(this._targetWalletUrl);if(!n)return void r(new a(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let o=!1;const i=i=>{const{data:c,origin:E}=i;if(c.type===e.SolanaMessageType.READY&&E===this._targetWalletOrigin&&!o)try{const{serializedTransaction:s,isVersionedTransaction:r,encoding:i}=d(t),a=this._buildRequest(e.SolanaMessageType.SIGN_TRANSACTION,{serializedTransaction:s,isVersionedTransaction:r,encoding:i});n.postMessage(a,this._targetWalletOrigin),o=!0}catch(e){l(),n.close(),r(e)}if(c.type===e.SolanaMessageType.SIGN_TRANSACTION&&E===this._targetWalletOrigin)if(l(),n.close(),c.payload.success)s(c.payload.result.signedTransaction);else{const t=c.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new a(t,c.payload.message))}},l=()=>{clearInterval(E),window.removeEventListener("message",i)},E=setInterval((()=>{n.closed&&(l(),r(new a(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",i)}))}async signAllTransactions(t){if(!this._connected)throw new a(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");for(let e=0;e<t.length;e++)try{this._verifyTransactionOwnership(t[e])}catch(t){if(t instanceof a)throw new a(t.code,`Transaction at index ${e}: ${t.message}`);throw t}return new Promise(((s,r)=>{const n=c(this._targetWalletUrl);if(!n)return void r(new a(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let o=!1;const i=i=>{const{data:c,origin:E}=i;if(c.type===e.SolanaMessageType.READY&&E===this._targetWalletOrigin&&!o)try{const s=t.map(((e,t)=>{const{serializedTransaction:s,isVersionedTransaction:r,encoding:n}=d(e);return{serializedTransaction:s,isVersionedTransaction:r,encoding:n,index:t}})),r=this._buildRequest(e.SolanaMessageType.SIGN_ALL_TRANSACTIONS,{serializedTransactions:s});n.postMessage(r,this._targetWalletOrigin),o=!0}catch(e){l(),n.close(),r(e)}if(c.type===e.SolanaMessageType.SIGN_ALL_TRANSACTIONS&&E===this._targetWalletOrigin)if(l(),n.close(),c.payload.success)s(c.payload.result.signedTransactions);else{const t=c.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new a(t,c.payload.message))}},l=()=>{clearInterval(E),window.removeEventListener("message",i)},E=setInterval((()=>{n.closed&&(l(),r(new a(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",i)}))}async signAndSendTransaction(t){if(!this._connected)throw new a(e.ErrorCode.DISCONNECTED,"Not connected. Please connect first.");return this._verifyTransactionOwnership(t),new Promise(((s,r)=>{const n=c(this._targetWalletUrl);if(!n)return void r(new a(e.ErrorCode.INTERNAL_ERROR,"Failed to open popup."));let o=!1;const i=i=>{const{data:c,origin:E}=i;if(c.type===e.SolanaMessageType.READY&&E===this._targetWalletOrigin&&!o)try{const{serializedTransaction:s,isVersionedTransaction:r,encoding:i}=d(t),a=this._buildRequest(e.SolanaMessageType.SIGN_AND_SEND_TRANSACTION,{serializedTransaction:s,isVersionedTransaction:r,encoding:i});n.postMessage(a,this._targetWalletOrigin),o=!0}catch(e){l(),n.close(),r(e)}if(c.type===e.SolanaMessageType.SIGN_AND_SEND_TRANSACTION&&E===this._targetWalletOrigin)if(l(),n.close(),c.payload.success)s(c.payload.result.signature);else{const t=c.payload.errorCode||e.ErrorCode.UNKNOWN_ERROR;r(new a(t,c.payload.message))}},l=()=>{clearInterval(E),window.removeEventListener("message",i)},E=setInterval((()=>{n.closed&&(l(),r(new a(e.ErrorCode.USER_REJECTED,"User closed the wallet window.")))}),500);window.addEventListener("message",i)}))}on(e,t){this._eventListeners[e]||(this._eventListeners[e]=[]),this._eventListeners[e].push(t)}off(e,t){this._eventListeners[e]&&(this._eventListeners[e]=this._eventListeners[e].filter((e=>e!==t)))}_emit(e,...t){this._eventListeners[e]&&this._eventListeners[e].forEach((e=>e(...t)))}}e.ProviderError=a,e.createErrorResponse=function(e,t,s,r,n){return{type:e,network:t,payload:{success:!1,message:i(s,r),errorCode:s,result:n}}},e.createSuccessResponse=function(e,t,s,r="Success"){return{type:e,network:t,payload:{success:!0,message:r,result:s}}},e.default=class{constructor(e={}){const t=e.walletUrl||"https://newwallet.io/transaction_signing";this.ethereum=new E(t),this.solana=new _(t)}isInstalled(){return!0}},e.getErrorMessage=i,Object.defineProperty(e,"__esModule",{value:!0})}));
